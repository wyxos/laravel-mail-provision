[
  {
    "content": "{\r\n  \"name\": \"wyxos/laravel-mail-provision\",\r\n  \"description\": \"Provision SparkPost sending/tracking domains and Cloudflare DNS records, and optionally configure SparkPost SMTP env settings.\",\r\n  \"type\": \"library\",\r\n  \"license\": \"MIT\",\r\n  \"autoload\": {\r\n    \"psr-4\": {\r\n      \"Wyxos\\\\LaravelMailProvision\\\\\": \"src/\"\r\n    }\r\n  },\r\n  \"require\": {\r\n    \"php\": \"^8.2|^8.3|^8.4\",\r\n    \"illuminate/console\": \"^11.0|^12.0\",\r\n    \"illuminate/http\": \"^11.0|^12.0\",\r\n    \"illuminate/support\": \"^11.0|^12.0\"\r\n  },\r\n  \"extra\": {\r\n    \"laravel\": {\r\n      \"providers\": [\r\n        \"Wyxos\\\\LaravelMailProvision\\\\MailProvisionServiceProvider\"\r\n      ]\r\n    }\r\n  },\r\n  \"keywords\": [\r\n    \"laravel\",\r\n    \"sparkpost\",\r\n    \"cloudflare\",\r\n    \"dns\",\r\n    \"email\"\r\n  ],\r\n  \"minimum-stability\": \"stable\",\r\n  \"prefer-stable\": true\r\n}\r\n",
    "path": "composer.json"
  },
  {
    "content": "# wyxos/laravel-mail-provision\n\nProvision SparkPost sending/tracking domains and Cloudflare DNS records, and optionally configure SparkPost SMTP mail settings in your `.env`.\n\n## Install\n\n```bash\ncomposer require wyxos/laravel-mail-provision\n```\n\n## Required Env\n\n- `CLOUDFLARE_API_TOKEN`\n- Either `CLOUDFLARE_ZONE_ID` or `CLOUDFLARE_ZONE_NAME` (otherwise it will infer a zone name from the last 2 labels of your domain)\n- SparkPost API key (one of):\n  - `SPARKPOST_PROVISIONING_KEY`\n  - `SPARKPOST_API_KEY`\n  - `MAIL_PASSWORD`\n\n## Usage\n\nProvision using `APP_DOMAIN` (or `APP_URL` host) when the domain argument is omitted:\n\n```bash\nphp artisan mail:provision-domain\n```\n\nProvision an explicit domain:\n\n```bash\nphp artisan mail:provision-domain nudge.example.com\n```\n\nBy default, the command updates your env file with SparkPost SMTP settings:\n\n```env\nMAIL_MAILER=smtp\nMAIL_HOST=smtp.sparkpostmail.com\nMAIL_PORT=587\nMAIL_USERNAME=SMTP_Injection\nMAIL_PASSWORD=<API_KEY>\nMAIL_ENCRYPTION=tls\nMAIL_FROM_ADDRESS=no-reply@${APP_DOMAIN}\nMAIL_FROM_NAME=\"${APP_NAME}\"\n```\n\nOptions:\n\n- `--api-key=` Provide SparkPost API key (used for provisioning and written to `MAIL_PASSWORD` when configuring env)\n- `--no-env` Skip writing env mail settings\n- `--env-file=` Override env file path to update\n- `--tracking=` Override tracking domain (defaults to `sp.<domain>`)\n- `--skip-spf`, `--skip-dmarc` Skip those TXT records\n\n## Notes\n\n- When publishing to Packagist, you should rely on git tags for versions. The local-path development version is set in this repo for convenience.\r\n",
    "path": "README.md"
  },
  {
    "content": "MIT License\n\nCopyright (c) 2026 Wyxos\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\r\n",
    "path": "LICENSE"
  },
  {
    "content": "/vendor/\n/.idea/\n/.phpunit.result.cache\n/.DS_Store\r\n",
    "path": ".gitignore"
  },
  {
    "content": "<?php\n\nreturn [\n    'sparkpost' => [\n        // Provisioning uses the SparkPost REST API key (not SMTP).\n        // Defaults to SPARKPOST_PROVISIONING_KEY, then SPARKPOST_API_KEY, then MAIL_PASSWORD.\n        'provisioning_key' => env('SPARKPOST_PROVISIONING_KEY', env('SPARKPOST_API_KEY', env('MAIL_PASSWORD'))),\n        'base_url' => env('SPARKPOST_API_BASE_URL', 'https://api.sparkpost.com'),\n        'tracking_cname_target' => env('SPARKPOST_TRACKING_CNAME_TARGET', 'v2.spgo.io'),\n        'subaccount' => env('SPARKPOST_SUBACCOUNT'),\n    ],\n    'cloudflare' => [\n        'api_token' => env('CLOUDFLARE_API_TOKEN'),\n        'zone_id' => env('CLOUDFLARE_ZONE_ID'),\n        'zone_name' => env('CLOUDFLARE_ZONE_NAME'),\n        'base_url' => env('CLOUDFLARE_API_BASE_URL', 'https://api.cloudflare.com/client/v4'),\n    ],\n];\n",
    "path": "config/mail-provision.php"
  },
  {
    "content": "<?php\n\nnamespace Wyxos\\LaravelMailProvision;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Wyxos\\LaravelMailProvision\\Console\\Commands\\ProvisionMailDomainCommand;\n\nclass MailProvisionServiceProvider extends ServiceProvider\n{\n    public function register(): void\n    {\n        $this->mergeConfigFrom(__DIR__.'/../config/mail-provision.php', 'mail-provision');\n    }\n\n    public function boot(): void\n    {\n        $this->publishes([\n            __DIR__.'/../config/mail-provision.php' => config_path('mail-provision.php'),\n        ], 'mail-provision-config');\n\n        if ($this->app->runningInConsole()) {\n            $this->commands([\n                ProvisionMailDomainCommand::class,\n            ]);\n        }\n    }\n}\n",
    "path": "src/MailProvisionServiceProvider.php"
  },
  {
    "content": "<?php\n\nnamespace Wyxos\\LaravelMailProvision\\Support;\n\nuse RuntimeException;\n\nfinal class EnvFile\n{\n    /**\n     * Set/replace multiple keys in an env file.\n     *\n     * Values must be passed as already-formatted env values (quoted if desired).\n     *\n     * @param  array<string, string>  $values\n     */\n    public static function set(string $path, array $values): void\n    {\n        $eol = PHP_EOL;\n        $contents = '';\n\n        if (is_file($path)) {\n            $contents = file_get_contents($path);\n            if ($contents === false) {\n                throw new RuntimeException(\"Unable to read env file at {$path}.\");\n            }\n\n            $eol = str_contains($contents, \"\\r\\n\") ? \"\\r\\n\" : \"\\n\";\n        }\n\n        $lines = $contents === '' ? [] : preg_split('/\\\\r\\\\n|\\\\n|\\\\r/', $contents);\n        if (! is_array($lines)) {\n            $lines = [];\n        }\n\n        foreach ($values as $key => $value) {\n            $pattern = '/^'.preg_quote($key, '/').'=.*/';\n            $foundIndex = null;\n            $newLines = [];\n\n            foreach ($lines as $i => $line) {\n                if (preg_match($pattern, $line) === 1) {\n                    if ($foundIndex === null) {\n                        $foundIndex = $i;\n                        $newLines[] = \"{$key}={$value}\";\n                    }\n\n                    // Drop duplicate definitions.\n                    continue;\n                }\n\n                $newLines[] = $line;\n            }\n\n            $lines = $newLines;\n\n            if ($foundIndex === null) {\n                $lines[] = \"{$key}={$value}\";\n            }\n        }\n\n        $final = implode($eol, $lines);\n        if ($final !== '' && ! str_ends_with($final, $eol)) {\n            $final .= $eol;\n        }\n\n        $dir = dirname($path);\n        if (! is_dir($dir)) {\n            if (! mkdir($dir, 0777, true) && ! is_dir($dir)) {\n                throw new RuntimeException(\"Unable to create env directory {$dir}.\");\n            }\n        }\n\n        if (file_put_contents($path, $final) === false) {\n            throw new RuntimeException(\"Unable to write env file at {$path}.\");\n        }\n    }\n}\n",
    "path": "src/Support/EnvFile.php"
  },
  {
    "content": "<?php\n\nnamespace Wyxos\\LaravelMailProvision\\Console\\Commands;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Http\\Client\\PendingRequest;\nuse Illuminate\\Http\\Client\\Response;\nuse Illuminate\\Support\\Facades\\Http;\nuse Illuminate\\Support\\Str;\nuse RuntimeException;\nuse Throwable;\nuse Wyxos\\LaravelMailProvision\\Support\\EnvFile;\n\nclass ProvisionMailDomainCommand extends Command\n{\n    protected $signature = 'mail:provision-domain\n        {domain? : Sending domain (defaults to APP_DOMAIN or APP_URL host)}\n        {--tracking= : Tracking domain (defaults to sp.<domain>)}\n        {--spf= : SPF TXT value (defaults to \"v=spf1 include:_spf.sparkpostmail.com ~all\")}\n        {--dmarc= : DMARC TXT value (defaults to \"v=DMARC1; p=none; adkim=r; aspf=r; pct=100\")}\n        {--api-key= : SparkPost API key (will be written to MAIL_PASSWORD if configuring env)}\n        {--no-env : Do not write SparkPost SMTP + APP_DOMAIN settings into the env file}\n        {--env-file= : Env file path to update (defaults to the current environment file)}\n        {--skip-spf : Skip SPF TXT provisioning}\n        {--skip-dmarc : Skip DMARC TXT provisioning}\n        {--timeout=900 : Max seconds to poll verification}\n        {--interval=15 : Poll interval in seconds}';\n\n    protected $description = 'Provision SparkPost + Cloudflare records for a sending domain and verify it';\n\n    private ?string $resolvedZoneId = null;\n\n    private ?string $currentDomain = null;\n\n    private ?string $sparkPostProvisioningKey = null;\n\n    public function handle(): int\n    {\n        try {\n            $domain = $this->resolveDomain();\n            $trackingDomain = $this->resolveTrackingDomain($domain);\n            $timeout = max(0, (int) $this->option('timeout'));\n            $interval = max(0, (int) $this->option('interval'));\n            $this->currentDomain = $domain;\n            $spfValue = $this->resolveSpfValue();\n            $dmarcValue = $this->resolveDmarcValue();\n\n            $apiKey = $this->resolveSparkPostApiKeyForProvisioning();\n\n            if (! (bool) $this->option('no-env')) {\n                $this->configureEnv(\n                    domain: $domain,\n                    apiKey: $apiKey,\n                    envPath: $this->resolveEnvFilePath(),\n                );\n            }\n\n            $this->line(\"Sending domain: {$domain}\");\n            $this->line(\"Tracking domain: {$trackingDomain}\");\n\n            $this->ensureTrackingDomain($trackingDomain);\n            $this->ensureSendingDomain($domain);\n\n            $dkimRecord = $this->resolveDkimRecord($domain);\n            $trackingTarget = (string) config('mail-provision.sparkpost.tracking_cname_target', 'v2.spgo.io');\n\n            $this->ensureCloudflareRecord(\n                name: $trackingDomain,\n                type: 'CNAME',\n                content: $trackingTarget,\n                proxied: false,\n            );\n\n            $this->ensureCloudflareRecord(\n                name: $dkimRecord['name'],\n                type: 'TXT',\n                content: $dkimRecord['value'],\n            );\n\n            if (! (bool) $this->option('skip-spf')) {\n                $this->ensureCloudflarePolicyRecord(\n                    name: $domain,\n                    desiredContent: $spfValue,\n                    prefix: 'v=spf1',\n                    label: 'SPF',\n                );\n            }\n\n            if (! (bool) $this->option('skip-dmarc')) {\n                $this->ensureCloudflarePolicyRecord(\n                    name: \"_dmarc.{$domain}\",\n                    desiredContent: $dmarcValue,\n                    prefix: 'v=dmarc1',\n                    label: 'DMARC',\n                );\n            }\n\n            if (! $this->pollTrackingVerification($trackingDomain, $timeout, $interval)) {\n                $this->error('Timed out waiting for SparkPost tracking domain verification.');\n\n                return self::FAILURE;\n            }\n\n            $this->ensureSendingTrackingDomain($domain, $trackingDomain);\n\n            if (! $this->pollVerification($domain, $trackingDomain, $timeout, $interval)) {\n                $this->error('Timed out waiting for SparkPost verification to complete.');\n\n                return self::FAILURE;\n            }\n\n            $this->info('Mail domain provisioning completed successfully.');\n\n            return self::SUCCESS;\n        } catch (Throwable $exception) {\n            $this->error($exception->getMessage());\n\n            return self::FAILURE;\n        }\n    }\n\n    private function resolveEnvFilePath(): string\n    {\n        $path = trim((string) ($this->option('env-file') ?? ''));\n\n        return $path !== '' ? $path : app()->environmentFilePath();\n    }\n\n    private function configureEnv(string $domain, string $apiKey, string $envPath): void\n    {\n        $desiredAppDomain = $this->normalizeDomain($domain);\n\n        EnvFile::set($envPath, [\n            'APP_DOMAIN' => $desiredAppDomain,\n            'MAIL_MAILER' => 'smtp',\n            'MAIL_HOST' => 'smtp.sparkpostmail.com',\n            'MAIL_PORT' => '587',\n            'MAIL_USERNAME' => 'SMTP_Injection',\n            'MAIL_PASSWORD' => $apiKey,\n            'MAIL_ENCRYPTION' => 'tls',\n            // phpdotenv supports variable expansion with ${...}\n            'MAIL_FROM_ADDRESS' => 'no-reply@${APP_DOMAIN}',\n            'MAIL_FROM_NAME' => '\"${APP_NAME}\"',\n        ]);\n\n        $this->line(\"Updated env file: {$envPath}\");\n    }\n\n    private function resolveDomain(): string\n    {\n        $candidate = (string) ($this->argument('domain') ?? '');\n        if ($candidate !== '') {\n            return $this->normalizeDomain($candidate);\n        }\n\n        $candidate = (string) config('app.domain', '');\n        if ($candidate !== '') {\n            return $this->normalizeDomain($candidate);\n        }\n\n        $host = (string) parse_url((string) config('app.url', ''), PHP_URL_HOST);\n        if ($host !== '') {\n            return $this->normalizeDomain($host);\n        }\n\n        throw new RuntimeException('No domain provided. Pass {domain} or set APP_DOMAIN / APP_URL.');\n    }\n\n    private function resolveTrackingDomain(string $domain): string\n    {\n        $candidate = (string) ($this->option('tracking') ?? '');\n\n        return $this->normalizeDomain($candidate !== '' ? $candidate : \"sp.{$domain}\");\n    }\n\n    private function normalizeDomain(string $domain): string\n    {\n        return Str::lower(trim($domain, \". \\t\\n\\r\\0\\x0B\"));\n    }\n\n    private function resolveSpfValue(): string\n    {\n        $value = trim((string) ($this->option('spf') ?? ''));\n        if ($value === '') {\n            $value = 'v=spf1 include:_spf.sparkpostmail.com ~all';\n        }\n\n        if (! Str::startsWith(Str::lower($value), 'v=spf1')) {\n            throw new RuntimeException('Invalid SPF value. It must start with \"v=spf1\".');\n        }\n\n        return $value;\n    }\n\n    private function resolveDmarcValue(): string\n    {\n        $value = trim((string) ($this->option('dmarc') ?? ''));\n        if ($value === '') {\n            $value = 'v=DMARC1; p=none; adkim=r; aspf=r; pct=100';\n        }\n\n        if (! Str::startsWith(Str::lower($value), 'v=dmarc1')) {\n            throw new RuntimeException('Invalid DMARC value. It must start with \"v=DMARC1\".');\n        }\n\n        return $value;\n    }\n\n    private function resolveSparkPostApiKeyForProvisioning(): string\n    {\n        if ($this->sparkPostProvisioningKey !== null && $this->sparkPostProvisioningKey !== '') {\n            return $this->sparkPostProvisioningKey;\n        }\n\n        $candidate = trim((string) ($this->option('api-key') ?? ''));\n        if ($candidate !== '') {\n            return $this->sparkPostProvisioningKey = $candidate;\n        }\n\n        $candidate = (string) config('mail-provision.sparkpost.provisioning_key', '');\n        if ($candidate !== '') {\n            return $this->sparkPostProvisioningKey = $candidate;\n        }\n\n        if ($this->input->isInteractive()) {\n            $entered = (string) $this->secret('SparkPost API key (will be stored in MAIL_PASSWORD)');\n            $entered = trim($entered);\n            if ($entered !== '') {\n                return $this->sparkPostProvisioningKey = $entered;\n            }\n        }\n\n        throw new RuntimeException('Missing SparkPost API key. Pass --api-key or set SPARKPOST_API_KEY / MAIL_PASSWORD.');\n    }\n\n    private function ensureTrackingDomain(string $trackingDomain): void\n    {\n        $encodedDomain = rawurlencode($trackingDomain);\n\n        $existing = $this->sparkPostClient()->get(\"api/v1/tracking-domains/{$encodedDomain}\");\n        if ($existing->status() !== 404) {\n            $this->ensureSparkPostSuccess($existing, \"Failed loading tracking domain {$trackingDomain}\");\n            $this->line(\"Tracking domain already exists: {$trackingDomain}\");\n\n            return;\n        }\n\n        $create = $this->sparkPostClient()->post('api/v1/tracking-domains', [\n            'domain' => $trackingDomain,\n        ]);\n\n        if ($create->status() === 409) {\n            $this->line(\"Tracking domain already exists: {$trackingDomain}\");\n\n            return;\n        }\n\n        $this->ensureSparkPostSuccess($create, \"Failed creating tracking domain {$trackingDomain}\");\n        $this->info(\"Created tracking domain: {$trackingDomain}\");\n    }\n\n    private function ensureSendingDomain(string $domain): void\n    {\n        $encodedDomain = rawurlencode($domain);\n        $existing = $this->sparkPostClient()->get(\"api/v1/sending-domains/{$encodedDomain}\");\n\n        if ($existing->status() === 404) {\n            $create = $this->sparkPostClient()->post('api/v1/sending-domains', [\n                'domain' => $domain,\n            ]);\n\n            if ($create->status() === 409) {\n                $this->line(\"Sending domain already exists: {$domain}\");\n\n                return;\n            }\n\n            $this->ensureSparkPostSuccess($create, \"Failed creating sending domain {$domain}\");\n            $this->info(\"Created sending domain: {$domain}\");\n\n            return;\n        }\n\n        $this->ensureSparkPostSuccess($existing, \"Failed loading sending domain {$domain}\");\n        $this->line(\"Sending domain already exists: {$domain}\");\n    }\n\n    private function ensureSendingTrackingDomain(string $domain, string $trackingDomain): void\n    {\n        $encodedDomain = rawurlencode($domain);\n        $existing = $this->sparkPostClient()->get(\"api/v1/sending-domains/{$encodedDomain}\");\n        $this->ensureSparkPostSuccess($existing, \"Failed loading sending domain {$domain}\");\n\n        $existingTrackingDomain = (string) data_get($existing->json(), 'results.tracking_domain', '');\n        if ($existingTrackingDomain !== '' && $this->normalizeDomain($existingTrackingDomain) === $trackingDomain) {\n            $this->line(\"Sending domain already bound to tracking domain: {$trackingDomain}\");\n\n            return;\n        }\n\n        $update = $this->sparkPostClient()->put(\"api/v1/sending-domains/{$encodedDomain}\", [\n            'tracking_domain' => $trackingDomain,\n        ]);\n        $this->ensureSparkPostSuccess($update, \"Failed updating sending domain {$domain}\");\n        $this->info(\"Bound sending domain to tracking domain: {$domain} -> {$trackingDomain}\");\n    }\n\n    private function pollTrackingVerification(string $trackingDomain, int $timeoutSeconds, int $intervalSeconds): bool\n    {\n        $deadline = microtime(true) + $timeoutSeconds;\n        $attempt = 1;\n\n        do {\n            $trackingStatus = $this->verifyTrackingDomain($trackingDomain);\n            $this->line(sprintf(\n                'Tracking verify attempt %d: cname_status=%s',\n                $attempt,\n                $trackingStatus['cname_status'] ?: 'unknown',\n            ));\n\n            if ($trackingStatus['verified']) {\n                return true;\n            }\n\n            if (microtime(true) >= $deadline) {\n                return false;\n            }\n\n            if ($intervalSeconds > 0) {\n                sleep($intervalSeconds);\n            }\n\n            $attempt++;\n        } while (true);\n    }\n\n    /**\n     * @return array{name: string, value: string}\n     */\n    private function resolveDkimRecord(string $domain): array\n    {\n        $encodedDomain = rawurlencode($domain);\n        $response = $this->sparkPostClient()->get(\"api/v1/sending-domains/{$encodedDomain}/dkim-keys/default\");\n        $this->ensureSparkPostSuccess($response, \"Failed loading DKIM key for {$domain}\");\n\n        $results = (array) data_get($response->json(), 'results', []);\n        $record = (string) data_get($results, 'dns.dkim_record', '');\n        $value = (string) data_get($results, 'dns.dkim_value', '');\n\n        if ($record !== '' && $value !== '') {\n            return [\n                'name' => $this->normalizeDomain($record),\n                'value' => $value,\n            ];\n        }\n\n        $selector = (string) data_get($results, 'selector', '');\n        $publicKey = (string) data_get($results, 'public', '');\n\n        if ($selector === '' || $publicKey === '') {\n            throw new RuntimeException(\"SparkPost did not return usable DKIM DNS values for {$domain}.\");\n        }\n\n        return [\n            'name' => \"{$this->normalizeDomain($selector)}._domainkey.{$domain}\",\n            'value' => \"v=DKIM1; k=rsa; p={$publicKey}\",\n        ];\n    }\n\n    private function ensureCloudflareRecord(string $name, string $type, string $content, ?bool $proxied = null): void\n    {\n        $zoneId = $this->resolveCloudflareZoneId();\n        $normalizedName = $this->normalizeDomain($name);\n        $normalizedType = Str::upper($type);\n\n        $find = $this->cloudflareClient()->get(\"zones/{$zoneId}/dns_records\", [\n            'type' => $normalizedType,\n            'name' => $normalizedName,\n            'per_page' => 100,\n        ]);\n\n        $findPayload = $this->ensureCloudflareSuccess($find, \"Failed checking Cloudflare {$normalizedType} {$normalizedName}\");\n        $existing = (array) data_get($findPayload, 'result.0', []);\n\n        $body = [\n            'type' => $normalizedType,\n            'name' => $normalizedName,\n            'content' => $content,\n            'ttl' => 1,\n        ];\n\n        if ($proxied !== null && $normalizedType === 'CNAME') {\n            $body['proxied'] = $proxied;\n        }\n\n        if ($existing !== []) {\n            $existingContent = (string) ($existing['content'] ?? '');\n            $existingProxied = (bool) ($existing['proxied'] ?? false);\n            $sameProxied = $proxied === null || $existingProxied === $proxied || $normalizedType !== 'CNAME';\n\n            if ($existingContent === $content && $sameProxied) {\n                $this->line(\"Cloudflare {$normalizedType} up-to-date: {$normalizedName}\");\n\n                return;\n            }\n\n            $recordId = (string) ($existing['id'] ?? '');\n            if ($recordId === '') {\n                throw new RuntimeException(\"Cloudflare returned {$normalizedType} record without an id for {$normalizedName}.\");\n            }\n\n            $update = $this->cloudflareClient()->put(\"zones/{$zoneId}/dns_records/{$recordId}\", $body);\n            $this->ensureCloudflareSuccess($update, \"Failed updating Cloudflare {$normalizedType} {$normalizedName}\");\n            $this->info(\"Updated Cloudflare {$normalizedType}: {$normalizedName}\");\n\n            return;\n        }\n\n        $create = $this->cloudflareClient()->post(\"zones/{$zoneId}/dns_records\", $body);\n        $this->ensureCloudflareSuccess($create, \"Failed creating Cloudflare {$normalizedType} {$normalizedName}\");\n        $this->info(\"Created Cloudflare {$normalizedType}: {$normalizedName}\");\n    }\n\n    private function ensureCloudflarePolicyRecord(string $name, string $desiredContent, string $prefix, string $label): void\n    {\n        $zoneId = $this->resolveCloudflareZoneId();\n        $normalizedName = $this->normalizeDomain($name);\n        $normalizedPrefix = Str::lower($prefix);\n\n        $find = $this->cloudflareClient()->get(\"zones/{$zoneId}/dns_records\", [\n            'type' => 'TXT',\n            'name' => $normalizedName,\n            'per_page' => 100,\n        ]);\n        $payload = $this->ensureCloudflareSuccess($find, \"Failed checking Cloudflare TXT {$normalizedName}\");\n        $records = array_values(array_filter((array) data_get($payload, 'result', []), function (mixed $record) use ($normalizedPrefix) {\n            $content = Str::lower((string) data_get($record, 'content', ''));\n\n            return Str::startsWith($content, $normalizedPrefix);\n        }));\n\n        if (count($records) > 1) {\n            throw new RuntimeException(\"Multiple {$label} TXT records found for {$normalizedName}; please clean up duplicates.\");\n        }\n\n        if (count($records) === 1) {\n            $record = $records[0];\n            $existingContent = (string) data_get($record, 'content', '');\n            if ($existingContent === $desiredContent) {\n                $this->line(\"Cloudflare {$label} TXT up-to-date: {$normalizedName}\");\n\n                return;\n            }\n\n            $recordId = (string) data_get($record, 'id', '');\n            if ($recordId === '') {\n                throw new RuntimeException(\"Cloudflare returned {$label} TXT without an id for {$normalizedName}.\");\n            }\n\n            $update = $this->cloudflareClient()->put(\"zones/{$zoneId}/dns_records/{$recordId}\", [\n                'type' => 'TXT',\n                'name' => $normalizedName,\n                'content' => $desiredContent,\n                'ttl' => 1,\n            ]);\n            $this->ensureCloudflareSuccess($update, \"Failed updating Cloudflare {$label} TXT {$normalizedName}\");\n            $this->info(\"Updated Cloudflare {$label} TXT: {$normalizedName}\");\n\n            return;\n        }\n\n        $create = $this->cloudflareClient()->post(\"zones/{$zoneId}/dns_records\", [\n            'type' => 'TXT',\n            'name' => $normalizedName,\n            'content' => $desiredContent,\n            'ttl' => 1,\n        ]);\n        $this->ensureCloudflareSuccess($create, \"Failed creating Cloudflare {$label} TXT {$normalizedName}\");\n        $this->info(\"Created Cloudflare {$label} TXT: {$normalizedName}\");\n    }\n\n    private function pollVerification(string $domain, string $trackingDomain, int $timeoutSeconds, int $intervalSeconds): bool\n    {\n        $deadline = microtime(true) + $timeoutSeconds;\n        $attempt = 1;\n\n        do {\n            $trackingStatus = $this->verifyTrackingDomain($trackingDomain);\n            $sendingStatus = $this->verifySendingDomain($domain);\n\n            $this->line(sprintf(\n                'Attempt %d: tracking=%s, dkim=%s, ownership=%s, compliance=%s',\n                $attempt,\n                $trackingStatus['cname_status'] ?: 'unknown',\n                $sendingStatus['dkim_status'] ?: 'unknown',\n                $sendingStatus['ownership_verified'] ? 'true' : 'false',\n                $sendingStatus['compliance_status'] ?: 'unknown',\n            ));\n\n            if ($trackingStatus['verified'] && $sendingStatus['verified']) {\n                return true;\n            }\n\n            if (microtime(true) >= $deadline) {\n                return false;\n            }\n\n            if ($intervalSeconds > 0) {\n                sleep($intervalSeconds);\n            }\n\n            $attempt++;\n        } while (true);\n    }\n\n    /**\n     * @return array{verified: bool, cname_status: string}\n     */\n    private function verifyTrackingDomain(string $trackingDomain): array\n    {\n        $encodedDomain = rawurlencode($trackingDomain);\n        $response = $this->sparkPostClient()->post(\"api/v1/tracking-domains/{$encodedDomain}/verify\");\n\n        if (! $response->successful()) {\n            if ($this->isRetryableVerificationError($response)) {\n                return [\n                    'verified' => false,\n                    'cname_status' => $this->extractSparkPostErrorMessage($response) ?: 'pending',\n                ];\n            }\n\n            $this->ensureSparkPostSuccess($response, \"Failed verifying tracking domain {$trackingDomain}\");\n        }\n\n        $results = (array) data_get($response->json(), 'results', []);\n        $cnameStatus = (string) data_get($results, 'cname_status', '');\n        $verified = (bool) data_get($results, 'verified', false) || Str::lower($cnameStatus) === 'valid';\n\n        return [\n            'verified' => $verified,\n            'cname_status' => $cnameStatus,\n        ];\n    }\n\n    /**\n     * @return array{verified: bool, dkim_status: string, ownership_verified: bool, compliance_status: string}\n     */\n    private function verifySendingDomain(string $domain): array\n    {\n        $encodedDomain = rawurlencode($domain);\n        $response = $this->sparkPostClient()->post(\"api/v1/sending-domains/{$encodedDomain}/verify\", [\n            'dkim_verify' => true,\n        ]);\n\n        if (! $response->successful()) {\n            if ($this->isRetryableVerificationError($response)) {\n                return [\n                    'verified' => false,\n                    'dkim_status' => 'pending',\n                    'ownership_verified' => false,\n                    'compliance_status' => 'pending',\n                ];\n            }\n\n            $this->ensureSparkPostSuccess($response, \"Failed verifying sending domain {$domain}\");\n        }\n\n        $results = (array) data_get($response->json(), 'results', []);\n        $dkimStatus = $this->extractSendingStatus($results, 'dkim_status');\n        $complianceStatus = $this->extractSendingStatus($results, 'compliance_status');\n        $ownershipVerified = filter_var(\n            $this->extractSendingStatus($results, 'ownership_verified'),\n            FILTER_VALIDATE_BOOL\n        ) ?: false;\n\n        return [\n            'verified' => Str::lower($dkimStatus) === 'valid' && $ownershipVerified,\n            'dkim_status' => $dkimStatus,\n            'ownership_verified' => $ownershipVerified,\n            'compliance_status' => $complianceStatus,\n        ];\n    }\n\n    private function extractSendingStatus(array $results, string $key): string\n    {\n        $value = data_get($results, $key);\n        if ($value === null) {\n            $value = data_get($results, \"status.{$key}\");\n        }\n\n        return is_bool($value) ? ($value ? 'true' : 'false') : (string) ($value ?? '');\n    }\n\n    private function sparkPostClient(): PendingRequest\n    {\n        $apiKey = $this->resolveSparkPostApiKeyForProvisioning();\n\n        $baseUrl = rtrim((string) config('mail-provision.sparkpost.base_url', 'https://api.sparkpost.com'), '/');\n        $request = Http::baseUrl($baseUrl)\n            ->acceptJson()\n            ->asJson()\n            ->withHeaders([\n                'Authorization' => $apiKey,\n            ]);\n\n        $subaccount = (string) config('mail-provision.sparkpost.subaccount', '');\n\n        if ($subaccount !== '') {\n            $request = $request->withHeaders([\n                'X-MSYS-SUBACCOUNT' => $subaccount,\n            ]);\n        }\n\n        return $request;\n    }\n\n    private function cloudflareClient(): PendingRequest\n    {\n        $apiToken = (string) config('mail-provision.cloudflare.api_token', '');\n        if ($apiToken === '') {\n            throw new RuntimeException('Missing Cloudflare API token. Set CLOUDFLARE_API_TOKEN.');\n        }\n\n        $baseUrl = rtrim(\n            (string) config('mail-provision.cloudflare.base_url', 'https://api.cloudflare.com/client/v4'),\n            '/'\n        );\n\n        return Http::baseUrl($baseUrl)\n            ->acceptJson()\n            ->asJson()\n            ->withToken($apiToken);\n    }\n\n    private function resolveCloudflareZoneId(): string\n    {\n        if ($this->resolvedZoneId !== null) {\n            return $this->resolvedZoneId;\n        }\n\n        $zoneId = (string) config('mail-provision.cloudflare.zone_id', '');\n        if ($zoneId !== '') {\n            return $this->resolvedZoneId = $zoneId;\n        }\n\n        $zoneName = (string) config('mail-provision.cloudflare.zone_name', '');\n        if ($zoneName === '') {\n            if ($this->currentDomain === null) {\n                throw new RuntimeException('Cannot infer Cloudflare zone without a domain.');\n            }\n\n            $zoneName = $this->inferZoneName($this->currentDomain);\n        }\n\n        $response = $this->cloudflareClient()->get('zones', [\n            'name' => $zoneName,\n            'status' => 'active',\n            'per_page' => 1,\n        ]);\n\n        $payload = $this->ensureCloudflareSuccess($response, \"Failed finding Cloudflare zone {$zoneName}\");\n        $resolvedZoneId = (string) data_get($payload, 'result.0.id', '');\n\n        if ($resolvedZoneId === '') {\n            throw new RuntimeException(\"Cloudflare zone not found for {$zoneName}. Set CLOUDFLARE_ZONE_ID.\");\n        }\n\n        return $this->resolvedZoneId = $resolvedZoneId;\n    }\n\n    private function inferZoneName(string $domain): string\n    {\n        $parts = explode('.', $domain);\n        $count = count($parts);\n\n        if ($count < 2) {\n            throw new RuntimeException(\n                \"Unable to infer Cloudflare zone from {$domain}. Set CLOUDFLARE_ZONE_NAME or CLOUDFLARE_ZONE_ID.\"\n            );\n        }\n\n        return implode('.', array_slice($parts, -2));\n    }\n\n    private function ensureSparkPostSuccess(Response $response, string $context): void\n    {\n        if ($response->successful()) {\n            return;\n        }\n\n        $message = (string) data_get($response->json(), 'errors.0.message', '');\n        if ($message === '') {\n            $message = $response->body();\n        }\n\n        throw new RuntimeException(\"{$context}. [{$response->status()}] {$message}\");\n    }\n\n    /**\n     * @return array<string, mixed>\n     */\n    private function ensureCloudflareSuccess(Response $response, string $context): array\n    {\n        if (! $response->successful()) {\n            throw new RuntimeException(\"{$context}. [{$response->status()}] {$response->body()}\");\n        }\n\n        $payload = $response->json();\n        if (! is_array($payload)) {\n            throw new RuntimeException(\"{$context}. Cloudflare returned an invalid payload.\");\n        }\n\n        if (($payload['success'] ?? false) === true) {\n            return $payload;\n        }\n\n        $message = (string) data_get($payload, 'errors.0.message', '');\n        if ($message === '') {\n            $message = json_encode($payload, JSON_UNESCAPED_SLASHES) ?: 'Unknown Cloudflare error';\n        }\n\n        throw new RuntimeException(\"{$context}. {$message}\");\n    }\n\n    private function isRetryableVerificationError(Response $response): bool\n    {\n        if (! in_array($response->status(), [400, 404, 409, 422], true)) {\n            return false;\n        }\n\n        $message = Str::lower($this->extractSparkPostErrorMessage($response));\n\n        return Str::contains($message, [\n            'not been verified',\n            'invalid',\n            'verify',\n            'dns',\n        ]);\n    }\n\n    private function extractSparkPostErrorMessage(Response $response): string\n    {\n        $message = (string) data_get($response->json(), 'errors.0.description', '');\n        if ($message !== '') {\n            return $message;\n        }\n\n        $message = (string) data_get($response->json(), 'errors.0.message', '');\n        if ($message !== '') {\n            return $message;\n        }\n\n        return '';\n    }\n}\n",
    "path": "src/Console/Commands/ProvisionMailDomainCommand.php"
  }
]
